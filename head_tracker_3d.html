<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Head Tracker - Johnny Lee Style</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
        }
        
        #video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #fff;
            border-radius: 8px;
            z-index: 100;
            transform: scaleX(-1); /* Mirror the video */
        }
        
        #calibration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        
        #calibration button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        
        #calibration button:hover {
            background: #45a049;
        }
        
        canvas {
            display: block;
        }
        
        .status {
            margin: 5px 0;
        }
        
        .status.good {
            color: #4CAF50;
        }
        
        .status.bad {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <div class="status" id="cameraStatus">Camera: Initializing...</div>
            <div class="status" id="trackingStatus">Tracking: Not Started</div>
            <div>Head X: <span id="headX">0.0</span></div>
            <div>Head Y: <span id="headY">0.0</span></div>
            <div>Distance: <span id="distance">0.0</span></div>
            <div style="margin-top: 10px;">
                <button onclick="startCalibration()">Calibrate</button>
                <button onclick="resetTracking()">Reset</button>
            </div>
        </div>
        
        <video id="video" autoplay muted></video>
        <canvas id="canvas"></canvas>
        
        <div id="calibration">
            <h3>Head Tracking Calibration</h3>
            <p>Position your head in the center of the camera view and click the button below.</p>
            <p>Make sure your face is clearly visible and well-lit.</p>
            <button onclick="calibrateCenter()">Calibrate Center Position</button>
            <button onclick="cancelCalibration()">Cancel</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script>
        // Three.js variables
        let scene, camera, renderer;
        let room, targets = [];
        
        // Head tracking variables
        let faceMesh;
        let videoElement;
        let cameraUtils;
        let isCalibrated = false;
        let calibrationData = {
            centerX: 0,
            centerY: 0,
            baseDistance: 0
        };
        
        // Tracking smoothing
        let smoothedX = 0;
        let smoothedY = 0;
        let smoothedDistance = 0;
        const smoothingFactor = 0.05;
        
        // Screen dimensions for mapping
        const screenWidth = 30; // Virtual screen width in 3D space
        const screenHeight = 20; // Virtual screen height in 3D space
        const maxTrackingDistance = 150; // Maximum head movement distance
        
        async function init() {
            await setupCamera();
            await setupFaceTracking();
            setup3DScene();
            animate();
        }
        
        async function setupCamera() {
            try {
                videoElement = document.getElementById('video');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: 640, 
                        height: 480,
                        facingMode: 'user'
                    }
                });
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    document.getElementById('cameraStatus').textContent = 'Camera: Ready';
                    document.getElementById('cameraStatus').className = 'status good';
                };
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                document.getElementById('cameraStatus').textContent = 'Camera: Error';
                document.getElementById('cameraStatus').className = 'status bad';
            }
        }
        
        async function setupFaceTracking() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onFaceResults);
            
            if (videoElement) {
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await faceMesh.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                camera.start();
            }
        }
        
        function onFaceResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // Get key facial landmarks
                const noseTip = landmarks[1]; // Nose tip
                const leftEye = landmarks[33]; // Left eye corner
                const rightEye = landmarks[263]; // Right eye corner
                
                // Calculate head position
                const headX = (leftEye.x + rightEye.x) / 2;
                const headY = (leftEye.y + rightEye.y) / 2;
                
                // Calculate distance based on eye distance
                const eyeDistance = Math.sqrt(
                    Math.pow(rightEye.x - leftEye.x, 2) + 
                    Math.pow(rightEye.y - leftEye.y, 2)
                );
                
                if (isCalibrated) {
                    updateHeadTracking(headX, headY, eyeDistance);
                    document.getElementById('trackingStatus').textContent = 'Tracking: Active';
                    document.getElementById('trackingStatus').className = 'status good';
                } else {
                    document.getElementById('trackingStatus').textContent = 'Tracking: Need Calibration';
                    document.getElementById('trackingStatus').className = 'status bad';
                }
            } else {
                document.getElementById('trackingStatus').textContent = 'Tracking: No Face Detected';
                document.getElementById('trackingStatus').className = 'status bad';
            }
        }
        
        function updateHeadTracking(headX, headY, eyeDistance) {
            // Calculate relative position from calibration center
            const deltaX = headX - calibrationData.centerX;
            const deltaY = headY - calibrationData.centerY;
            const deltaDistance = eyeDistance - calibrationData.baseDistance;
            
            // Map to 3D space coordinates
            const mappedX = (deltaX * maxTrackingDistance) * 0.5; // Amplify movement
            const mappedY = -(deltaY * maxTrackingDistance) * 0.5; // Invert Y and amplify
            const mappedDistance = deltaDistance * 1000; // Scale distance changes
            
            // Apply smoothing
            smoothedX = smoothedX * (1 - smoothingFactor) + mappedX * smoothingFactor;
            smoothedY = smoothedY * (1 - smoothingFactor) + mappedY * smoothingFactor;
            smoothedDistance = smoothedDistance * (1 - smoothingFactor) + mappedDistance * smoothingFactor;
            
            // Update camera position to create parallax effect
            updateCameraPosition(smoothedX, smoothedY, smoothedDistance);
            
            // Update UI
            document.getElementById('headX').textContent = smoothedX.toFixed(1);
            document.getElementById('headY').textContent = smoothedY.toFixed(1);
            document.getElementById('distance').textContent = smoothedDistance.toFixed(1);
        }
        
        function updateCameraPosition(x, y, distance) {
            // Position camera based on head position
            const baseDistance = 25;
            const cameraX = x * 0.1; // Scale down movement
            const cameraY = y * 0.1;
            const cameraZ = baseDistance + distance * 0.01;
            
            camera.position.set(cameraX, cameraY, cameraZ);
            camera.lookAt(0, 0, 0);
            
            // Update projection matrix for off-axis perspective
            updateOffAxisProjection(x, y);
        }
        
        function updateOffAxisProjection(offsetX, offsetY) {
            const aspect = window.innerWidth / window.innerHeight;
            const fov = 60;
            const near = 0.1;
            const far = 1000;
            
            // Convert FOV to radians
            const fovRad = fov * Math.PI / 180;
            const top = near * Math.tan(fovRad / 2);
            const bottom = -top;
            const right = top * aspect;
            const left = -right;
            
            // Apply off-axis projection
            const offsetScale = 0.005;
            const leftOffset = left + offsetX * offsetScale;
            const rightOffset = right + offsetX * offsetScale;
            const topOffset = top - offsetY * offsetScale;
            const bottomOffset = bottom - offsetY * offsetScale;
            
            camera.projectionMatrix.makePerspective(
                leftOffset, rightOffset, topOffset, bottomOffset, near, far
            );
        }
        
        function setup3DScene() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 25);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'), 
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            createRoom();
            createTargets();
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
        }
        
        function createRoom() {
            const roomGroup = new THREE.Group();
            
            // Room dimensions
            const width = 40;
            const height = 25;
            const depth = 40;
            
            // Material for grid lines
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x666666,
                transparent: true,
                opacity: 0.6
            });
            
            // Create floor grid
            const floorGeometry = new THREE.BufferGeometry();
            const floorPoints = [];
            
            for (let i = -depth/2; i <= depth/2; i += 2) {
                floorPoints.push(-width/2, -height/2, i);
                floorPoints.push(width/2, -height/2, i);
            }
            
            for (let i = -width/2; i <= width/2; i += 2) {
                floorPoints.push(i, -height/2, -depth/2);
                floorPoints.push(i, -height/2, depth/2);
            }
            
            floorGeometry.setAttribute('position', new THREE.Float32BufferAttribute(floorPoints, 3));
            const floorGrid = new THREE.LineSegments(floorGeometry, lineMaterial);
            roomGroup.add(floorGrid);
            
            // Create ceiling grid
            const ceilingGeometry = new THREE.BufferGeometry();
            const ceilingPoints = [];
            
            for (let i = -depth/2; i <= depth/2; i += 2) {
                ceilingPoints.push(-width/2, height/2, i);
                ceilingPoints.push(width/2, height/2, i);
            }
            
            for (let i = -width/2; i <= width/2; i += 2) {
                ceilingPoints.push(i, height/2, -depth/2);
                ceilingPoints.push(i, height/2, depth/2);
            }
            
            ceilingGeometry.setAttribute('position', new THREE.Float32BufferAttribute(ceilingPoints, 3));
            const ceilingGrid = new THREE.LineSegments(ceilingGeometry, lineMaterial);
            roomGroup.add(ceilingGrid);
            
            // Create walls
            createWall(roomGroup, width, height, depth, 'left');
            createWall(roomGroup, width, height, depth, 'right');
            createWall(roomGroup, width, height, depth, 'back');
            
            scene.add(roomGroup);
            room = roomGroup;
        }
        
        function createWall(roomGroup, width, height, depth, side) {
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x666666,
                transparent: true,
                opacity: 0.6
            });
            
            const wallGeometry = new THREE.BufferGeometry();
            const wallPoints = [];
            
            if (side === 'left') {
                for (let i = -depth/2; i <= depth/2; i += 2) {
                    wallPoints.push(-width/2, -height/2, i);
                    wallPoints.push(-width/2, height/2, i);
                }
                for (let i = -height/2; i <= height/2; i += 2) {
                    wallPoints.push(-width/2, i, -depth/2);
                    wallPoints.push(-width/2, i, depth/2);
                }
            } else if (side === 'right') {
                for (let i = -depth/2; i <= depth/2; i += 2) {
                    wallPoints.push(width/2, -height/2, i);
                    wallPoints.push(width/2, height/2, i);
                }
                for (let i = -height/2; i <= height/2; i += 2) {
                    wallPoints.push(width/2, i, -depth/2);
                    wallPoints.push(width/2, i, depth/2);
                }
            } else if (side === 'back') {
                for (let i = -width/2; i <= width/2; i += 2) {
                    wallPoints.push(i, -height/2, -depth/2);
                    wallPoints.push(i, height/2, -depth/2);
                }
                for (let i = -height/2; i <= height/2; i += 2) {
                    wallPoints.push(-width/2, i, -depth/2);
                    wallPoints.push(width/2, i, -depth/2);
                }
            }
            
            wallGeometry.setAttribute('position', new THREE.Float32BufferAttribute(wallPoints, 3));
            const wallGrid = new THREE.LineSegments(wallGeometry, lineMaterial);
            roomGroup.add(wallGrid);
        }
        
        
        function createTargets() {
    // Create dartboard-like targets with concentric rings
    const positions = [
        {x: -8, y: 3, z: -15},
        {x: 5, y: 8, z: -18},
        {x: -12, y: -2, z: -12},
        {x: 10, y: -5, z: -16},
        {x: 0, y: 6, z: -20},
        {x: -6, y: -8, z: -14},
        {x: 8, y: 2, z: -19},
        {x: -15, y: 5, z: -17}
    ];
    
    positions.forEach((pos, index) => {
        const targetGroup = new THREE.Group();
        
        // Calculate scale based on depth (farther = smaller)
        const baseDistance = 12;
        const currentDistance = Math.abs(pos.z);
        const scale = baseDistance / currentDistance;
        
        // Create concentric dartboard rings
        const ringData = [
            { innerRadius: 0, outerRadius: 0.8 * scale, color: 0xff0000 }, // Red center
            { innerRadius: 0.8 * scale, outerRadius: 1.4 * scale, color: 0xffffff }, // White ring
            { innerRadius: 1.4 * scale, outerRadius: 2.0 * scale, color: 0xff0000 }, // Red ring
            { innerRadius: 2.0 * scale, outerRadius: 2.6 * scale, color: 0xffffff }, // White ring
            { innerRadius: 2.6 * scale, outerRadius: 3.2 * scale, color: 0xff0000 }  // Red outer ring
        ];
        
        // Create each ring
        ringData.forEach(ring => {
            const ringGeometry = new THREE.RingGeometry(ring.innerRadius, ring.outerRadius, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: ring.color,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            targetGroup.add(ringMesh);
        });
        
        // Add center dot
        const dotGeometry = new THREE.CircleGeometry(0.2 * scale, 16);
        const dotMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x000000,
            transparent: true,
            opacity: 0.8
        });
        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
        dot.position.z = 0.01;
        targetGroup.add(dot);
        
        // Position the target group
        targetGroup.position.set(pos.x, pos.y, pos.z);
        targetGroup.lookAt(0, 0, 25); // Face the camera
        
        // Create line perpendicular to dartboard (extending straight back)
        const lineLength = 8; // Length of the perpendicular line
        const lineGeometry = new THREE.BufferGeometry();
        
        // Calculate perpendicular direction (since dartboard faces camera, extend in -z direction)
        const linePoints = [
            pos.x, pos.y, pos.z,  // Start at target center
            pos.x, pos.y, pos.z - lineLength  // Extend straight back
        ];
        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePoints, 3));
        
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff,
            transparent: true,
            opacity: 0.4
        });
        
        const perpLine = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(perpLine);
        
        scene.add(targetGroup);
        targets.push(targetGroup);
    });
}
        function startCalibration() {
            document.getElementById('calibration').style.display = 'block';
        }
        
        function calibrateCenter() {
            // This would typically capture the current head position
            // For now, we'll use default values
            calibrationData.centerX = 0.5; // Center of camera view
            calibrationData.centerY = 0.5;
            calibrationData.baseDistance = 0.1; // Base eye distance
            
            isCalibrated = true;
            document.getElementById('calibration').style.display = 'none';
            
            // Reset smoothed values
            smoothedX = 0;
            smoothedY = 0;
            smoothedDistance = 0;
        }
        
        function cancelCalibration() {
            document.getElementById('calibration').style.display = 'none';
        }
        
        function resetTracking() {
            isCalibrated = false;
            smoothedX = 0;
            smoothedY = 0;
            smoothedDistance = 0;
            camera.position.set(0, 0, 25);
            camera.lookAt(0, 0, 0);
            camera.projectionMatrix.makePerspective(-1, 1, 1, -1, 0.1, 1000);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate targets slightly for visual interest
            targets.forEach((target, index) => {
                target.rotation.z += 0.01 * (index % 2 === 0 ? 1 : -1);
            });
            
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>